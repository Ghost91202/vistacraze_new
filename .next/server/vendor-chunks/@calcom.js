"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@calcom";
exports.ids = ["vendor-chunks/@calcom"];
exports.modules = {

/***/ "(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@calcom/embed-react/dist/Cal.es.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ hr),\n/* harmony export */   getCalApi: () => (/* binding */ Er)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst fr = \"https://app.cal.com/embed/embed.js\";\nfunction X(C = fr) {\n  (function(g, m, y) {\n    let p = function(u, d) {\n      u.q.push(d);\n    }, R = g.document;\n    g.Cal = g.Cal || function() {\n      let u = g.Cal, d = arguments;\n      if (u.loaded || (u.ns = {}, u.q = u.q || [], R.head.appendChild(R.createElement(\"script\")).src = m, u.loaded = !0), d[0] === y) {\n        const l = function() {\n          p(l, arguments);\n        }, b = d[1];\n        l.q = l.q || [], typeof b == \"string\" ? (u.ns[b] = u.ns[b] || l, p(u.ns[b], d), p(u, [\"initNamespace\", b])) : p(u, d);\n        return;\n      }\n      p(u, d);\n    };\n  })(\n    window,\n    //! Replace it with \"https://cal.com/embed.js\" or the URL where you have embed.js installed\n    C,\n    \"init\"\n  );\n  /*!  Copying ends here. */\n  return window.Cal;\n}\nX.toString();\nfunction cr(C) {\n  const [g, m] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    m(() => X(C));\n  }, []), g;\n}\nvar H = { exports: {} }, A = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Te;\nfunction dr() {\n  if (Te)\n    return A;\n  Te = 1;\n  var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.fragment\"), y = Object.prototype.hasOwnProperty, p = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, R = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function u(d, l, b) {\n    var f, _ = {}, w = null, $ = null;\n    b !== void 0 && (w = \"\" + b), l.key !== void 0 && (w = \"\" + l.key), l.ref !== void 0 && ($ = l.ref);\n    for (f in l)\n      y.call(l, f) && !R.hasOwnProperty(f) && (_[f] = l[f]);\n    if (d && d.defaultProps)\n      for (f in l = d.defaultProps, l)\n        _[f] === void 0 && (_[f] = l[f]);\n    return { $$typeof: g, type: d, key: w, ref: $, props: _, _owner: p.current };\n  }\n  return A.Fragment = m, A.jsx = u, A.jsxs = u, A;\n}\nvar I = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar we;\nfunction vr() {\n  return we || (we = 1,  true && function() {\n    var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.portal\"), y = Symbol.for(\"react.fragment\"), p = Symbol.for(\"react.strict_mode\"), R = Symbol.for(\"react.profiler\"), u = Symbol.for(\"react.provider\"), d = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), b = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), _ = Symbol.for(\"react.memo\"), w = Symbol.for(\"react.lazy\"), $ = Symbol.for(\"react.offscreen\"), Z = Symbol.iterator, Pe = \"@@iterator\";\n    function xe(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = Z && e[Z] || e[Pe];\n      return typeof r == \"function\" ? r : null;\n    }\n    var x = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function h(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        je(\"error\", e, t);\n      }\n    }\n    function je(e, r, t) {\n      {\n        var n = x.ReactDebugCurrentFrame, o = n.getStackAddendum();\n        o !== \"\" && (r += \"%s\", t = t.concat([o]));\n        var s = t.map(function(i) {\n          return String(i);\n        });\n        s.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, s);\n      }\n    }\n    var ke = !1, De = !1, Fe = !1, Ae = !1, Ie = !1, Q;\n    Q = Symbol.for(\"react.module.reference\");\n    function $e(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === y || e === R || Ie || e === p || e === b || e === f || Ae || e === $ || ke || De || Fe || typeof e == \"object\" && e !== null && (e.$$typeof === w || e.$$typeof === _ || e.$$typeof === u || e.$$typeof === d || e.$$typeof === l || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === Q || e.getModuleId !== void 0));\n    }\n    function We(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var o = r.displayName || r.name || \"\";\n      return o !== \"\" ? t + \"(\" + o + \")\" : t;\n    }\n    function ee(e) {\n      return e.displayName || \"Context\";\n    }\n    function O(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && h(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case y:\n          return \"Fragment\";\n        case m:\n          return \"Portal\";\n        case R:\n          return \"Profiler\";\n        case p:\n          return \"StrictMode\";\n        case b:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case d:\n            var r = e;\n            return ee(r) + \".Consumer\";\n          case u:\n            var t = e;\n            return ee(t._context) + \".Provider\";\n          case l:\n            return We(e, e.render, \"ForwardRef\");\n          case _:\n            var n = e.displayName || null;\n            return n !== null ? n : O(e.type) || \"Memo\";\n          case w: {\n            var o = e, s = o._payload, i = o._init;\n            try {\n              return O(i(s));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var P = Object.assign, D = 0, re, te, ne, ae, ie, oe, ue;\n    function se() {\n    }\n    se.__reactDisabledLog = !0;\n    function Ye() {\n      {\n        if (D === 0) {\n          re = console.log, te = console.info, ne = console.warn, ae = console.error, ie = console.group, oe = console.groupCollapsed, ue = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: se,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        D++;\n      }\n    }\n    function Le() {\n      {\n        if (D--, D === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: P({}, e, {\n              value: re\n            }),\n            info: P({}, e, {\n              value: te\n            }),\n            warn: P({}, e, {\n              value: ne\n            }),\n            error: P({}, e, {\n              value: ae\n            }),\n            group: P({}, e, {\n              value: ie\n            }),\n            groupCollapsed: P({}, e, {\n              value: oe\n            }),\n            groupEnd: P({}, e, {\n              value: ue\n            })\n          });\n        }\n        D < 0 && h(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var V = x.ReactCurrentDispatcher, M;\n    function W(e, r, t) {\n      {\n        if (M === void 0)\n          try {\n            throw Error();\n          } catch (o) {\n            var n = o.stack.trim().match(/\\n( *(at )?)/);\n            M = n && n[1] || \"\";\n          }\n        return `\n` + M + e;\n      }\n    }\n    var q = !1, Y;\n    {\n      var Ne = typeof WeakMap == \"function\" ? WeakMap : Map;\n      Y = new Ne();\n    }\n    function le(e, r) {\n      if (!e || q)\n        return \"\";\n      {\n        var t = Y.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      q = !0;\n      var o = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var s;\n      s = V.current, V.current = null, Ye();\n      try {\n        if (r) {\n          var i = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(i.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(i, []);\n            } catch (S) {\n              n = S;\n            }\n            Reflect.construct(e, [], i);\n          } else {\n            try {\n              i.call();\n            } catch (S) {\n              n = S;\n            }\n            e.call(i.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (S) {\n            n = S;\n          }\n          e();\n        }\n      } catch (S) {\n        if (S && n && typeof S.stack == \"string\") {\n          for (var a = S.stack.split(`\n`), E = n.stack.split(`\n`), c = a.length - 1, v = E.length - 1; c >= 1 && v >= 0 && a[c] !== E[v]; )\n            v--;\n          for (; c >= 1 && v >= 0; c--, v--)\n            if (a[c] !== E[v]) {\n              if (c !== 1 || v !== 1)\n                do\n                  if (c--, v--, v < 0 || a[c] !== E[v]) {\n                    var T = `\n` + a[c].replace(\" at new \", \" at \");\n                    return e.displayName && T.includes(\"<anonymous>\") && (T = T.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && Y.set(e, T), T;\n                  }\n                while (c >= 1 && v >= 0);\n              break;\n            }\n        }\n      } finally {\n        q = !1, V.current = s, Le(), Error.prepareStackTrace = o;\n      }\n      var k = e ? e.displayName || e.name : \"\", _e = k ? W(k) : \"\";\n      return typeof e == \"function\" && Y.set(e, _e), _e;\n    }\n    function Ue(e, r, t) {\n      return le(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function L(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return le(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case b:\n          return W(\"Suspense\");\n        case f:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case l:\n            return Ue(e.render);\n          case _:\n            return L(e.type, r, t);\n          case w: {\n            var n = e, o = n._payload, s = n._init;\n            try {\n              return L(s(o), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var N = Object.prototype.hasOwnProperty, fe = {}, ce = x.ReactDebugCurrentFrame;\n    function U(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        ce.setExtraStackFrame(t);\n      } else\n        ce.setExtraStackFrame(null);\n    }\n    function Me(e, r, t, n, o) {\n      {\n        var s = Function.call.bind(N);\n        for (var i in e)\n          if (s(e, i)) {\n            var a = void 0;\n            try {\n              if (typeof e[i] != \"function\") {\n                var E = Error((n || \"React class\") + \": \" + t + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[i] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw E.name = \"Invariant Violation\", E;\n              }\n              a = e[i](r, i, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (c) {\n              a = c;\n            }\n            a && !(a instanceof Error) && (U(o), h(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, i, typeof a), U(null)), a instanceof Error && !(a.message in fe) && (fe[a.message] = !0, U(o), h(\"Failed %s type: %s\", t, a.message), U(null));\n          }\n      }\n    }\n    var qe = Array.isArray;\n    function B(e) {\n      return qe(e);\n    }\n    function Be(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Je(e) {\n      try {\n        return de(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function de(e) {\n      return \"\" + e;\n    }\n    function ve(e) {\n      if (Je(e))\n        return h(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Be(e)), de(e);\n    }\n    var F = x.ReactCurrentOwner, Ge = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, pe, ge, J;\n    J = {};\n    function ze(e) {\n      if (N.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ke(e) {\n      if (N.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function He(e, r) {\n      if (typeof e.ref == \"string\" && F.current && r && F.current.stateNode !== r) {\n        var t = O(F.current.type);\n        J[t] || (h('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', O(F.current.type), e.ref), J[t] = !0);\n      }\n    }\n    function Xe(e, r) {\n      {\n        var t = function() {\n          pe || (pe = !0, h(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function Ze(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, h(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var Qe = function(e, r, t, n, o, s, i) {\n      var a = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: g,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: i,\n        // Record the component responsible for creating this element.\n        _owner: s\n      };\n      return a._store = {}, Object.defineProperty(a._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(a, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(a, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: o\n      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;\n    };\n    function er(e, r, t, n, o) {\n      {\n        var s, i = {}, a = null, E = null;\n        t !== void 0 && (ve(t), a = \"\" + t), Ke(r) && (ve(r.key), a = \"\" + r.key), ze(r) && (E = r.ref, He(r, o));\n        for (s in r)\n          N.call(r, s) && !Ge.hasOwnProperty(s) && (i[s] = r[s]);\n        if (e && e.defaultProps) {\n          var c = e.defaultProps;\n          for (s in c)\n            i[s] === void 0 && (i[s] = c[s]);\n        }\n        if (a || E) {\n          var v = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          a && Xe(i, v), E && Ze(i, v);\n        }\n        return Qe(e, a, E, o, n, F.current, i);\n      }\n    }\n    var G = x.ReactCurrentOwner, me = x.ReactDebugCurrentFrame;\n    function j(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        me.setExtraStackFrame(t);\n      } else\n        me.setExtraStackFrame(null);\n    }\n    var z;\n    z = !1;\n    function K(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === g;\n    }\n    function be() {\n      {\n        if (G.current) {\n          var e = O(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function rr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var he = {};\n    function tr(e) {\n      {\n        var r = be();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = tr(r);\n        if (he[t])\n          return;\n        he[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + O(e._owner.type) + \".\"), j(e), h('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), j(null);\n      }\n    }\n    function ye(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (B(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            K(n) && Ee(n, r);\n          }\n        else if (K(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var o = xe(e);\n          if (typeof o == \"function\" && o !== e.entries)\n            for (var s = o.call(e), i; !(i = s.next()).done; )\n              K(i.value) && Ee(i.value, r);\n        }\n      }\n    }\n    function nr(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === l || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === _))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = O(r);\n          Me(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !z) {\n          z = !0;\n          var o = O(r);\n          h(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", o || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && h(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ar(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            j(e), h(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), j(null);\n            break;\n          }\n        }\n        e.ref !== null && (j(e), h(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), j(null));\n      }\n    }\n    function Re(e, r, t, n, o, s) {\n      {\n        var i = $e(e);\n        if (!i) {\n          var a = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (a += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var E = rr(o);\n          E ? a += E : a += be();\n          var c;\n          e === null ? c = \"null\" : B(e) ? c = \"array\" : e !== void 0 && e.$$typeof === g ? (c = \"<\" + (O(e.type) || \"Unknown\") + \" />\", a = \" Did you accidentally export a JSX literal instead of a component?\") : c = typeof e, h(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", c, a);\n        }\n        var v = er(e, r, t, o, s);\n        if (v == null)\n          return v;\n        if (i) {\n          var T = r.children;\n          if (T !== void 0)\n            if (n)\n              if (B(T)) {\n                for (var k = 0; k < T.length; k++)\n                  ye(T[k], e);\n                Object.freeze && Object.freeze(T);\n              } else\n                h(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ye(T, e);\n        }\n        return e === y ? ar(v) : nr(v), v;\n      }\n    }\n    function ir(e, r, t) {\n      return Re(e, r, t, !0);\n    }\n    function or(e, r, t) {\n      return Re(e, r, t, !1);\n    }\n    var ur = or, sr = ir;\n    I.Fragment = y, I.jsx = ur, I.jsxs = sr;\n  }()), I;\n}\n false ? 0 : H.exports = vr();\nvar pr = H.exports;\nconst gr = pr.jsx, mr = function(g) {\n  const {\n    calLink: m,\n    calOrigin: y,\n    namespace: p = \"\",\n    config: R,\n    initConfig: u = {},\n    embedJsUrl: d,\n    ...l\n  } = g;\n  if (!m)\n    throw new Error(\"calLink is required\");\n  const b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), f = cr(d), _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!f || b.current || !_.current)\n      return;\n    b.current = !0;\n    const w = _.current;\n    p ? (f(\"init\", p, {\n      ...u,\n      origin: y\n    }), f.ns[p](\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    })) : (f(\"init\", {\n      ...u,\n      origin: y\n    }), f(\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    }));\n  }, [f, m, R, p, y, u]), f ? /* @__PURE__ */ gr(\"div\", {\n    ref: _,\n    ...l\n  }) : null;\n}, hr = mr;\nfunction Er(C) {\n  const g = typeof C == \"string\" ? { embedJsUrl: C } : C ?? {}, { namespace: m = \"\", embedJsUrl: y } = g;\n  return new Promise(function p(R) {\n    const u = X(y);\n    u(\"init\", m);\n    const d = m ? u.ns[m] : u;\n    if (!d) {\n      setTimeout(() => {\n        p(R);\n      }, 50);\n      return;\n    }\n    R(d);\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhbGNvbS9lbWJlZC1yZWFjdC9kaXN0L0NhbC5lcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUU7QUFDbkIsU0FBUyxnREFBRTtBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSw2Q0FBRSxxQkFBcUIsNkNBQUU7QUFDckMsU0FBUyxnREFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxxQ0FBcUMsZ0JBQWdCLFNBQVMsSUFBSSxtQ0FBbUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anNoYWRzbi8uL25vZGVfbW9kdWxlcy9AY2FsY29tL2VtYmVkLXJlYWN0L2Rpc3QvQ2FsLmVzLm1qcz8xYTdjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPZSwgeyB1c2VTdGF0ZSBhcyBsciwgdXNlRWZmZWN0IGFzIFNlLCB1c2VSZWYgYXMgQ2UgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGZyID0gXCJodHRwczovL2FwcC5jYWwuY29tL2VtYmVkL2VtYmVkLmpzXCI7XG5mdW5jdGlvbiBYKEMgPSBmcikge1xuICAoZnVuY3Rpb24oZywgbSwgeSkge1xuICAgIGxldCBwID0gZnVuY3Rpb24odSwgZCkge1xuICAgICAgdS5xLnB1c2goZCk7XG4gICAgfSwgUiA9IGcuZG9jdW1lbnQ7XG4gICAgZy5DYWwgPSBnLkNhbCB8fCBmdW5jdGlvbigpIHtcbiAgICAgIGxldCB1ID0gZy5DYWwsIGQgPSBhcmd1bWVudHM7XG4gICAgICBpZiAodS5sb2FkZWQgfHwgKHUubnMgPSB7fSwgdS5xID0gdS5xIHx8IFtdLCBSLmhlYWQuYXBwZW5kQ2hpbGQoUi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKS5zcmMgPSBtLCB1LmxvYWRlZCA9ICEwKSwgZFswXSA9PT0geSkge1xuICAgICAgICBjb25zdCBsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcChsLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBiID0gZFsxXTtcbiAgICAgICAgbC5xID0gbC5xIHx8IFtdLCB0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gKHUubnNbYl0gPSB1Lm5zW2JdIHx8IGwsIHAodS5uc1tiXSwgZCksIHAodSwgW1wiaW5pdE5hbWVzcGFjZVwiLCBiXSkpIDogcCh1LCBkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcCh1LCBkKTtcbiAgICB9O1xuICB9KShcbiAgICB3aW5kb3csXG4gICAgLy8hIFJlcGxhY2UgaXQgd2l0aCBcImh0dHBzOi8vY2FsLmNvbS9lbWJlZC5qc1wiIG9yIHRoZSBVUkwgd2hlcmUgeW91IGhhdmUgZW1iZWQuanMgaW5zdGFsbGVkXG4gICAgQyxcbiAgICBcImluaXRcIlxuICApO1xuICAvKiEgIENvcHlpbmcgZW5kcyBoZXJlLiAqL1xuICByZXR1cm4gd2luZG93LkNhbDtcbn1cblgudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGNyKEMpIHtcbiAgY29uc3QgW2csIG1dID0gbHIoKTtcbiAgcmV0dXJuIFNlKCgpID0+IHtcbiAgICBtKCgpID0+IFgoQykpO1xuICB9LCBbXSksIGc7XG59XG52YXIgSCA9IHsgZXhwb3J0czoge30gfSwgQSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIFRlO1xuZnVuY3Rpb24gZHIoKSB7XG4gIGlmIChUZSlcbiAgICByZXR1cm4gQTtcbiAgVGUgPSAxO1xuICB2YXIgQyA9IE9lLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBwID0gQy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgUiA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIHUoZCwgbCwgYikge1xuICAgIHZhciBmLCBfID0ge30sIHcgPSBudWxsLCAkID0gbnVsbDtcbiAgICBiICE9PSB2b2lkIDAgJiYgKHcgPSBcIlwiICsgYiksIGwua2V5ICE9PSB2b2lkIDAgJiYgKHcgPSBcIlwiICsgbC5rZXkpLCBsLnJlZiAhPT0gdm9pZCAwICYmICgkID0gbC5yZWYpO1xuICAgIGZvciAoZiBpbiBsKVxuICAgICAgeS5jYWxsKGwsIGYpICYmICFSLmhhc093blByb3BlcnR5KGYpICYmIChfW2ZdID0gbFtmXSk7XG4gICAgaWYgKGQgJiYgZC5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKGYgaW4gbCA9IGQuZGVmYXVsdFByb3BzLCBsKVxuICAgICAgICBfW2ZdID09PSB2b2lkIDAgJiYgKF9bZl0gPSBsW2ZdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogZywgdHlwZTogZCwga2V5OiB3LCByZWY6ICQsIHByb3BzOiBfLCBfb3duZXI6IHAuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBBLkZyYWdtZW50ID0gbSwgQS5qc3ggPSB1LCBBLmpzeHMgPSB1LCBBO1xufVxudmFyIEkgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciB3ZTtcbmZ1bmN0aW9uIHZyKCkge1xuICByZXR1cm4gd2UgfHwgKHdlID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBDID0gT2UsIGcgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIHkgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHAgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIFIgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgZiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBfID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIHcgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgJCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIFogPSBTeW1ib2wuaXRlcmF0b3IsIFBlID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24geGUoZSkge1xuICAgICAgaWYgKGUgPT09IG51bGwgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgciA9IFogJiYgZVtaXSB8fCBlW1BlXTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHggPSBDLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIGgoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShyID4gMSA/IHIgLSAxIDogMCksIG4gPSAxOyBuIDwgcjsgbisrKVxuICAgICAgICAgIHRbbiAtIDFdID0gYXJndW1lbnRzW25dO1xuICAgICAgICBqZShcImVycm9yXCIsIGUsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBqZShlLCByLCB0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBuID0geC5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBvID0gbi5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIG8gIT09IFwiXCIgJiYgKHIgKz0gXCIlc1wiLCB0ID0gdC5jb25jYXQoW29dKSk7XG4gICAgICAgIHZhciBzID0gdC5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzLnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIHIpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2VdLCBjb25zb2xlLCBzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtlID0gITEsIERlID0gITEsIEZlID0gITEsIEFlID0gITEsIEllID0gITEsIFE7XG4gICAgUSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uICRlKGUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSB5IHx8IGUgPT09IFIgfHwgSWUgfHwgZSA9PT0gcCB8fCBlID09PSBiIHx8IGUgPT09IGYgfHwgQWUgfHwgZSA9PT0gJCB8fCBrZSB8fCBEZSB8fCBGZSB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgKGUuJCR0eXBlb2YgPT09IHcgfHwgZS4kJHR5cGVvZiA9PT0gXyB8fCBlLiQkdHlwZW9mID09PSB1IHx8IGUuJCR0eXBlb2YgPT09IGQgfHwgZS4kJHR5cGVvZiA9PT0gbCB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgIC8vIHdpdGguXG4gICAgICBlLiQkdHlwZW9mID09PSBRIHx8IGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXZShlLCByLCB0KSB7XG4gICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgbyA9IHIuZGlzcGxheU5hbWUgfHwgci5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbyAhPT0gXCJcIiA/IHQgKyBcIihcIiArIG8gKyBcIilcIiA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVlKGUpIHtcbiAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKGUpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlLnRhZyA9PSBcIm51bWJlclwiICYmIGgoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBtOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBwOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICB2YXIgciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gZWUocikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHZhciB0ID0gZTtcbiAgICAgICAgICAgIHJldHVybiBlZSh0Ll9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgcmV0dXJuIFdlKGUsIGUucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBfOlxuICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbiAhPT0gbnVsbCA/IG4gOiBPKGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSB3OiB7XG4gICAgICAgICAgICB2YXIgbyA9IGUsIHMgPSBvLl9wYXlsb2FkLCBpID0gby5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBPKGkocykpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBQID0gT2JqZWN0LmFzc2lnbiwgRCA9IDAsIHJlLCB0ZSwgbmUsIGFlLCBpZSwgb2UsIHVlO1xuICAgIGZ1bmN0aW9uIHNlKCkge1xuICAgIH1cbiAgICBzZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBZZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEQgPT09IDApIHtcbiAgICAgICAgICByZSA9IGNvbnNvbGUubG9nLCB0ZSA9IGNvbnNvbGUuaW5mbywgbmUgPSBjb25zb2xlLndhcm4sIGFlID0gY29uc29sZS5lcnJvciwgaWUgPSBjb25zb2xlLmdyb3VwLCBvZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIHVlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogZSxcbiAgICAgICAgICAgIGxvZzogZSxcbiAgICAgICAgICAgIHdhcm46IGUsXG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIGdyb3VwOiBlLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGUsXG4gICAgICAgICAgICBncm91cEVuZDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gTGUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChELS0sIEQgPT09IDApIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogYWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGllXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBvZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgRCA8IDAgJiYgaChcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBWID0geC5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBNO1xuICAgIGZ1bmN0aW9uIFcoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICBpZiAoTSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgICAgIHZhciBuID0gby5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIE0gPSBuICYmIG5bMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgTSArIGU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBxID0gITEsIFk7XG4gICAge1xuICAgICAgdmFyIE5lID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIFkgPSBuZXcgTmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGUoZSwgcikge1xuICAgICAgaWYgKCFlIHx8IHEpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IFkuZ2V0KGUpO1xuICAgICAgICBpZiAodCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgICAgdmFyIG47XG4gICAgICBxID0gITA7XG4gICAgICB2YXIgbyA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcztcbiAgICAgIHMgPSBWLmN1cnJlbnQsIFYuY3VycmVudCA9IG51bGwsIFllKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHZhciBpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChpLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICAgIG4gPSBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgICAgbiA9IFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNhbGwoaS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICBuID0gUztcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgIGlmIChTICYmIG4gJiYgdHlwZW9mIFMuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBTLnN0YWNrLnNwbGl0KGBcbmApLCBFID0gbi5zdGFjay5zcGxpdChgXG5gKSwgYyA9IGEubGVuZ3RoIC0gMSwgdiA9IEUubGVuZ3RoIC0gMTsgYyA+PSAxICYmIHYgPj0gMCAmJiBhW2NdICE9PSBFW3ZdOyApXG4gICAgICAgICAgICB2LS07XG4gICAgICAgICAgZm9yICg7IGMgPj0gMSAmJiB2ID49IDA7IGMtLSwgdi0tKVxuICAgICAgICAgICAgaWYgKGFbY10gIT09IEVbdl0pIHtcbiAgICAgICAgICAgICAgaWYgKGMgIT09IDEgfHwgdiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKGMtLSwgdi0tLCB2IDwgMCB8fCBhW2NdICE9PSBFW3ZdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBUID0gYFxuYCArIGFbY10ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgVC5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChUID0gVC5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgWS5zZXQoZSwgVCksIFQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGMgPj0gMSAmJiB2ID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcSA9ICExLCBWLmN1cnJlbnQgPSBzLCBMZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG87XG4gICAgICB9XG4gICAgICB2YXIgayA9IGUgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSA6IFwiXCIsIF9lID0gayA/IFcoaykgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBZLnNldChlLCBfZSksIF9lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVZShlLCByLCB0KSB7XG4gICAgICByZXR1cm4gbGUoZSwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWZShlKSB7XG4gICAgICB2YXIgciA9IGUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHIgJiYgci5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTChlLCByLCB0KSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBsZShlLCBWZShlKSk7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIFcoZSk7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIHJldHVybiBXKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gVyhcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICByZXR1cm4gVWUoZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgXzpcbiAgICAgICAgICAgIHJldHVybiBMKGUudHlwZSwgciwgdCk7XG4gICAgICAgICAgY2FzZSB3OiB7XG4gICAgICAgICAgICB2YXIgbiA9IGUsIG8gPSBuLl9wYXlsb2FkLCBzID0gbi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBMKHMobyksIHIsIHQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIE4gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBmZSA9IHt9LCBjZSA9IHguUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBVKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBMKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIGNlLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1lKGUsIHIsIHQsIG4sIG8pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoTik7XG4gICAgICAgIGZvciAodmFyIGkgaW4gZSlcbiAgICAgICAgICBpZiAocyhlLCBpKSkge1xuICAgICAgICAgICAgdmFyIGEgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVbaV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIEUgPSBFcnJvcigobiB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgdCArIFwiIHR5cGUgYFwiICsgaSArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgZVtpXSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgRS5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYSA9IGVbaV0ociwgaSwgbiwgdCwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhICYmICEoYSBpbnN0YW5jZW9mIEVycm9yKSAmJiAoVShvKSwgaChcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgbiB8fCBcIlJlYWN0IGNsYXNzXCIsIHQsIGksIHR5cGVvZiBhKSwgVShudWxsKSksIGEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGEubWVzc2FnZSBpbiBmZSkgJiYgKGZlW2EubWVzc2FnZV0gPSAhMCwgVShvKSwgaChcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCB0LCBhLm1lc3NhZ2UpLCBVKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBxZSA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gQihlKSB7XG4gICAgICByZXR1cm4gcWUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIHQgPSByICYmIGVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEplKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZShlKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZShlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlKGUpIHtcbiAgICAgIGlmIChKZShlKSlcbiAgICAgICAgcmV0dXJuIGgoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgQmUoZSkpLCBkZShlKTtcbiAgICB9XG4gICAgdmFyIEYgPSB4LlJlYWN0Q3VycmVudE93bmVyLCBHZSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIHBlLCBnZSwgSjtcbiAgICBKID0ge307XG4gICAgZnVuY3Rpb24gemUoZSkge1xuICAgICAgaWYgKE4uY2FsbChlLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBLZShlKSB7XG4gICAgICBpZiAoTi5jYWxsKGUsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhlKGUsIHIpIHtcbiAgICAgIGlmICh0eXBlb2YgZS5yZWYgPT0gXCJzdHJpbmdcIiAmJiBGLmN1cnJlbnQgJiYgciAmJiBGLmN1cnJlbnQuc3RhdGVOb2RlICE9PSByKSB7XG4gICAgICAgIHZhciB0ID0gTyhGLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIEpbdF0gfHwgKGgoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBPKEYuY3VycmVudC50eXBlKSwgZS5yZWYpLCBKW3RdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBYZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGUgfHwgKHBlID0gITAsIGgoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWmUoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGdlIHx8IChnZSA9ICEwLCBoKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBRZSA9IGZ1bmN0aW9uKGUsIHIsIHQsIG4sIG8sIHMsIGkpIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IGcsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAga2V5OiByLFxuICAgICAgICByZWY6IHQsXG4gICAgICAgIHByb3BzOiBpLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gYS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IG5cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IG9cbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKGEucHJvcHMpLCBPYmplY3QuZnJlZXplKGEpKSwgYTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVyKGUsIHIsIHQsIG4sIG8pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHMsIGkgPSB7fSwgYSA9IG51bGwsIEUgPSBudWxsO1xuICAgICAgICB0ICE9PSB2b2lkIDAgJiYgKHZlKHQpLCBhID0gXCJcIiArIHQpLCBLZShyKSAmJiAodmUoci5rZXkpLCBhID0gXCJcIiArIHIua2V5KSwgemUocikgJiYgKEUgPSByLnJlZiwgSGUociwgbykpO1xuICAgICAgICBmb3IgKHMgaW4gcilcbiAgICAgICAgICBOLmNhbGwociwgcykgJiYgIUdlLmhhc093blByb3BlcnR5KHMpICYmIChpW3NdID0gcltzXSk7XG4gICAgICAgIGlmIChlICYmIGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIGMgPSBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKHMgaW4gYylcbiAgICAgICAgICAgIGlbc10gPT09IHZvaWQgMCAmJiAoaVtzXSA9IGNbc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIHx8IEUpIHtcbiAgICAgICAgICB2YXIgdiA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IFwiVW5rbm93blwiIDogZTtcbiAgICAgICAgICBhICYmIFhlKGksIHYpLCBFICYmIFplKGksIHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRZShlLCBhLCBFLCBvLCBuLCBGLmN1cnJlbnQsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRyA9IHguUmVhY3RDdXJyZW50T3duZXIsIG1lID0geC5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIGooZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IEwoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIHo7XG4gICAgeiA9ICExO1xuICAgIGZ1bmN0aW9uIEsoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLiQkdHlwZW9mID09PSBnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEcuY3VycmVudCkge1xuICAgICAgICAgIHZhciBlID0gTyhHLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgZSArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnIoZSkge1xuICAgICAge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCB0ID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgdCArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGUgPSB7fTtcbiAgICBmdW5jdGlvbiB0cihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gYmUoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIHQgJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyB0ICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRWUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciB0ID0gdHIocik7XG4gICAgICAgIGlmIChoZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhlW3RdID0gITA7XG4gICAgICAgIHZhciBuID0gXCJcIjtcbiAgICAgICAgZSAmJiBlLl9vd25lciAmJiBlLl9vd25lciAhPT0gRy5jdXJyZW50ICYmIChuID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBPKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBqKGUpLCBoKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB0LCBuKSwgaihudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24geWUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChCKGUpKVxuICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdmFyIG4gPSBlW3RdO1xuICAgICAgICAgICAgSyhuKSAmJiBFZShuLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEsoZSkpXG4gICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoZSkge1xuICAgICAgICAgIHZhciBvID0geGUoZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiAmJiBvICE9PSBlLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gby5jYWxsKGUpLCBpOyAhKGkgPSBzLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBLKGkudmFsdWUpICYmIEVlKGkudmFsdWUsIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5yKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBlLnR5cGU7XG4gICAgICAgIGlmIChyID09IG51bGwgfHwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0O1xuICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiAoci4kJHR5cGVvZiA9PT0gbCB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICByLiQkdHlwZW9mID09PSBfKSlcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIG4gPSBPKHIpO1xuICAgICAgICAgIE1lKHQsIGUucHJvcHMsIFwicHJvcFwiLCBuLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICF6KSB7XG4gICAgICAgICAgeiA9ICEwO1xuICAgICAgICAgIHZhciBvID0gTyhyKTtcbiAgICAgICAgICBoKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIG8gfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiByLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIXIuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIGgoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXIoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gT2JqZWN0LmtleXMoZS5wcm9wcyksIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIHZhciBuID0gclt0XTtcbiAgICAgICAgICBpZiAobiAhPT0gXCJjaGlsZHJlblwiICYmIG4gIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIGooZSksIGgoXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCBuKSwgaihudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlLnJlZiAhPT0gbnVsbCAmJiAoaihlKSwgaChcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBqKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmUoZSwgciwgdCwgbiwgbywgcykge1xuICAgICAge1xuICAgICAgICB2YXIgaSA9ICRlKGUpO1xuICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICB2YXIgYSA9IFwiXCI7XG4gICAgICAgICAgKGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID09PSAwKSAmJiAoYSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBFID0gcnIobyk7XG4gICAgICAgICAgRSA/IGEgKz0gRSA6IGEgKz0gYmUoKTtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBlID09PSBudWxsID8gYyA9IFwibnVsbFwiIDogQihlKSA/IGMgPSBcImFycmF5XCIgOiBlICE9PSB2b2lkIDAgJiYgZS4kJHR5cGVvZiA9PT0gZyA/IChjID0gXCI8XCIgKyAoTyhlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIGEgPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSA6IGMgPSB0eXBlb2YgZSwgaChcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBjLCBhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IGVyKGUsIHIsIHQsIG8sIHMpO1xuICAgICAgICBpZiAodiA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHZhciBUID0gci5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoVCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgIGlmIChCKFQpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBULmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgeWUoVFtrXSwgZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKFQpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBoKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgeWUoVCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgPT09IHkgPyBhcih2KSA6IG5yKHYpLCB2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gUmUoZSwgciwgdCwgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gUmUoZSwgciwgdCwgITEpO1xuICAgIH1cbiAgICB2YXIgdXIgPSBvciwgc3IgPSBpcjtcbiAgICBJLkZyYWdtZW50ID0geSwgSS5qc3ggPSB1ciwgSS5qc3hzID0gc3I7XG4gIH0oKSksIEk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBILmV4cG9ydHMgPSBkcigpIDogSC5leHBvcnRzID0gdnIoKTtcbnZhciBwciA9IEguZXhwb3J0cztcbmNvbnN0IGdyID0gcHIuanN4LCBtciA9IGZ1bmN0aW9uKGcpIHtcbiAgY29uc3Qge1xuICAgIGNhbExpbms6IG0sXG4gICAgY2FsT3JpZ2luOiB5LFxuICAgIG5hbWVzcGFjZTogcCA9IFwiXCIsXG4gICAgY29uZmlnOiBSLFxuICAgIGluaXRDb25maWc6IHUgPSB7fSxcbiAgICBlbWJlZEpzVXJsOiBkLFxuICAgIC4uLmxcbiAgfSA9IGc7XG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxMaW5rIGlzIHJlcXVpcmVkXCIpO1xuICBjb25zdCBiID0gQ2UoITEpLCBmID0gY3IoZCksIF8gPSBDZShudWxsKTtcbiAgcmV0dXJuIFNlKCgpID0+IHtcbiAgICBpZiAoIWYgfHwgYi5jdXJyZW50IHx8ICFfLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgYi5jdXJyZW50ID0gITA7XG4gICAgY29uc3QgdyA9IF8uY3VycmVudDtcbiAgICBwID8gKGYoXCJpbml0XCIsIHAsIHtcbiAgICAgIC4uLnUsXG4gICAgICBvcmlnaW46IHlcbiAgICB9KSwgZi5uc1twXShcImlubGluZVwiLCB7XG4gICAgICBlbGVtZW50T3JTZWxlY3RvcjogdyxcbiAgICAgIGNhbExpbms6IG0sXG4gICAgICBjb25maWc6IFJcbiAgICB9KSkgOiAoZihcImluaXRcIiwge1xuICAgICAgLi4udSxcbiAgICAgIG9yaWdpbjogeVxuICAgIH0pLCBmKFwiaW5saW5lXCIsIHtcbiAgICAgIGVsZW1lbnRPclNlbGVjdG9yOiB3LFxuICAgICAgY2FsTGluazogbSxcbiAgICAgIGNvbmZpZzogUlxuICAgIH0pKTtcbiAgfSwgW2YsIG0sIFIsIHAsIHksIHVdKSwgZiA/IC8qIEBfX1BVUkVfXyAqLyBncihcImRpdlwiLCB7XG4gICAgcmVmOiBfLFxuICAgIC4uLmxcbiAgfSkgOiBudWxsO1xufSwgaHIgPSBtcjtcbmZ1bmN0aW9uIEVyKEMpIHtcbiAgY29uc3QgZyA9IHR5cGVvZiBDID09IFwic3RyaW5nXCIgPyB7IGVtYmVkSnNVcmw6IEMgfSA6IEMgPz8ge30sIHsgbmFtZXNwYWNlOiBtID0gXCJcIiwgZW1iZWRKc1VybDogeSB9ID0gZztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHAoUikge1xuICAgIGNvbnN0IHUgPSBYKHkpO1xuICAgIHUoXCJpbml0XCIsIG0pO1xuICAgIGNvbnN0IGQgPSBtID8gdS5uc1ttXSA6IHU7XG4gICAgaWYgKCFkKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcChSKTtcbiAgICAgIH0sIDUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUihkKTtcbiAgfSk7XG59XG5leHBvcnQge1xuICBociBhcyBkZWZhdWx0LFxuICBFciBhcyBnZXRDYWxBcGlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs\n");

/***/ })

};
;